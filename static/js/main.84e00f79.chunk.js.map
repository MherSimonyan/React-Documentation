{"version":3,"sources":["serviceWorker.js","index.js"],"names":["Boolean","window","location","hostname","match","ReactDOM","render","useState","count","setCount","useEffect","document","title","onClick","querySelector"],"mappings":"gKAYoBA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DC2JNC,IAASC,OAAO,mBAnBhB,WAAoB,IAAD,EACSC,mBAAS,GADlB,mBACVC,EADU,KACHC,EADG,KASjB,OALAC,qBAAU,WAERC,SAASC,MAAT,4DAA8BJ,EAA9B,0BAIA,6BACE,gFAAcA,EAAd,uBACA,4BAAQK,QAAS,kBAAMJ,EAASD,EAAQ,KAAxC,2EAOU,MAAaG,SAASG,cAAc,W","file":"static/js/main.84e00f79.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","// @flow\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport * as serviceWorker from './serviceWorker';\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// class ErrorBoundary extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { error: null, errorInfo: null };\n//   }\n\n//   componentDidCatch(error, errorInfo) {\n//     // Catch errors in any components below and re-render with error message\n//     this.setState({\n//       error: error,\n//       errorInfo: errorInfo\n//     })\n//     // You can also log error messages to an error reporting service here\n//   }\n\n//   render() {\n//     if (this.state.errorInfo) {\n//       // Error path\n//       return (\n//         <div>\n//           <h2>Something went wrong.</h2>\n//           <details style={{ whiteSpace: 'pre-wrap' }}>\n//             {this.state.error && this.state.error.toString()}\n//             <br />\n//             {this.state.errorInfo.componentStack}\n//           </details>\n//         </div>\n//       );\n//     }\n//     // Normally, just render children\n//     return this.props.children;\n//   }\n// }\n\n// class BuggyCounter extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { counter: 0 };\n//     this.handleClick = this.handleClick.bind(this);\n//   }\n\n//   handleClick() {\n//     this.setState(({ counter }) => ({\n//       counter: counter + 1\n//     }));\n//   }\n\n//   render() {\n//     if (this.state.counter === 5) {\n//       // Simulate a JS error\n//       throw new Error('I crashed!');\n//     }\n//     return <h1 onClick={this.handleClick}>{this.state.counter}</h1>;\n//   }\n// }\n\n// function App() {\n//   return (\n//     <div>\n//       <p>\n//         <b>\n//           This is an example of error boundaries in React 16.\n//           <br /><br />\n//           Click on the numbers to increase the counters.\n//           <br />\n//           The counter is programmed to throw when it reaches 5. This simulates a JavaScript error in a component.\n//         </b>\n//       </p>\n//       <hr />\n//       <ErrorBoundary>\n//         <p>These two counters are inside the same error boundary. If one crashes, the error boundary will replace both of them.</p>\n//         <BuggyCounter />\n//         <BuggyCounter />\n//       </ErrorBoundary>\n//       <hr />\n//       <p>These two counters are each inside of their own error boundary. So if one crashes, the other is not affected.</p>\n//       <ErrorBoundary><BuggyCounter /></ErrorBoundary>\n//       <ErrorBoundary><BuggyCounter /></ErrorBoundary>\n//     </div>\n//   );\n// }\n\n\n// function logProps(Component) {\n//   class LogProps extends React.Component {\n//     componentDidUpdate(prevProps) {\n//       console.log('old props:', prevProps);\n//       console.log('new props:', this.props);\n//     }\n\n//     componentDidMount() {\n//       console.log(this.props)\n//     }\n\n//     render() {\n//       const {forwardedRef, ...rest} = this.props;\n\n//       // Передаём в качестве рефа проп \"forwardedRef\"\n//       return <Component ref={forwardedRef} {...rest} />;\n//     }\n//   }\n\n//   // Обратите внимание, что React.forwardRef передает \"ref\" вторым аргументом.\n//   // Мы можем передать его дальше как проп, например, \"forwardedRef\",\n//   // а потом привязать его к компоненту.\n//   return React.forwardRef((props, ref) => {\n//     return <LogProps {...props} forwardedRef={ref} />;\n//   });\n// }\n\n// const FancyButton = React.forwardRef((props, ref) => (\n//   <button ref={ref} className=\"FancyButton\">\n//     {props.children}\n//   </button>\n// ));\n\n// // Теперь реф будет указывать непосредственно на DOM-узел button:\n// const ref = React.createRef();\n\n// let OtheFancyButton = logProps(FancyButton)\n\n// ReactDOM.render(\n//   <OtheFancyButton ref={ref}>Click me!</OtheFancyButton>,\n//   document.getElementById('root')\n// );\n\n// function Example() {\n//   return (\n//     <div>\n//       Some text.\n//       <h2>A heading</h2>\n//       More text.\n//       <h2>Another heading</h2>\n//       Even more text.\n//     </div>\n//    );\n// }\n// ReactDOM.render(<Example />, document.getElementById('root'));\n\nimport { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // Аналогично componentDidMount и componentDidUpdate:\n  useEffect(() => {\n    // Обновляем заголовок документа с помощью API браузера\n    document.title = `Вы нажали ${count} раз`;\n  });\n\n  return (\n    <div>\n      <p>Вы нажали {count} раз</p>\n      <button onClick={() => setCount(count + 1)}>\n        Нажми на меня\n      </button>\n    </div>\n  );\n}\n\nReactDOM.render(<Example />, document.querySelector(\"#root\"));\n"],"sourceRoot":""}